import java.util.*;
//Пирамидальная сортировка (или сортировка кучей, HeapSort) — это метод сортировки сравнением, основанный на такой структуре данных как двоичная куча.
// Она похожа на сортировку выбором, где мы сначала ищем максимальный элемент и помещаем его в конец. Далее мы повторяем ту же операцию для оставшихся элементов.
//Давайте сначала определим законченное двоичное дерево. Законченное двоичное дерево — это двоичное дерево, в котором каждый уровень, за исключением, возможно, последнего,
// имеет полный набор узлов, и все листья расположены как можно левее
//Двоичная куча — это законченное двоичное дерево, в котором элементы хранятся в особом порядке: значение в родительском узле больше (или меньше) значений в его двух дочерних узлах.
// Первый вариант называется max-heap, а второй — min-heap. Куча может быть представлена двоичным деревом или массивом.
//Поскольку двоичная куча — это законченное двоичное дерево, ее можно легко представить в виде массива, а представление на основе массива является эффективным с точки зрения расхода памяти.
// Если родительский узел хранится в индексе I, левый дочерний элемент может быть вычислен как 2 I + 1, а правый дочерний элемент — как 2 I + 2 (при условии, что индексирование начинается с 0).

//Алгоритм пирамидальной сортировки в порядке по возрастанию:
//
//
//Постройте max-heap из входных данных.
//На данном этапе самый большой элемент хранится в корне кучи. Замените его на последний элемент кучи, а затем уменьшите ее размер на 1.
// Наконец, преобразуйте полученное дерево в max-heap с новым корнем.
//Повторяйте вышеуказанные шаги, пока размер кучи больше 1.

//Входные данные: 4, 10, 3, 5, 1
//         4(0)
//        /   \
//     10(1)   3(2)
//    /   \
// 5(3)    1(4)
//Числа в скобках представляют индексы в представлении данных в виде массива.
//Применение процедуры heapify к индексу 1:
//         4(0)
//        /   \
//    10(1)    3(2)
//    /   \
//5(3)    1(4)
//Применение процедуры heapify к индексу 0:
//        10(0)
//        /  \
//     5(1)  3(2)
//    /   \
// 4(3)    1(4)
//Процедура heapify вызывает себя рекурсивно для создания кучи  сверху вниз.

public class Pyramid {
    public void sort(int arr[]) {
        int N = arr.length;

        // Построение кучи
        for (int i = N / 2 - 1; i >= 0; i--)
            heapify(arr, N, i);

        // Берем элемент
        for (int i = N - 1; i > 0; i--) {
            // Перемещение текущего корня в конец
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;

            // вызвать max heapify на уменьшенной куче
            heapify(arr, i, 0);
        }
    }
    void heapify(int arr[], int N, int i) {
        int largest = i; // Корень
        int l = 2 * i + 1;
        int r = 2 * i + 2;

        // Если левый ребенок больше корня
        if (l < N && arr[l] > arr[largest])
            largest = l;

        // Если правый ребенок больше, чем самый крупный на данный момент
        if (r < N && arr[r] > arr[largest])
            largest = r;

        // Если наибольший не является корнем
        if (largest != i) {
            int swap = arr[i];
            arr[i] = arr[largest];
            arr[largest] = swap;

            // Рекурсивно сгруппировать затронутое поддерево
            heapify(arr, N, largest);
        }
    }

    //Вывод
    static void printArray(int arr[]) {
        int N = arr.length;

        for (int i = 0; i < N; ++i)
            System.out.print(arr[i] + " ");
        System.out.println();
    }

    public static void main(String args[]) {
        Scanner obj = new Scanner(System.in);
        int size = obj.nextInt();
        int[] arr = new int[size];
        for (int i = 0; i < size; i++) {
            arr[i] = obj.nextInt();
        }
        int N = arr.length;

        Pyramid ob = new Pyramid();
        ob.sort(arr);
        printArray(arr);
    }
}